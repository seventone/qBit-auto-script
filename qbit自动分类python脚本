
#一、创建Dockerfile并修改权限
#例如：/vol1/1000/Docker/python/Dockerfile

#Dockerfile文件内容
###
FROM lscr.io/linuxserver/qbittorrent:latest

# 1. 安装Python3、pip3（系统级）
RUN apk update && \
    apk add --no-cache python3 py3-pip && \
    # 2. 创建虚拟环境（路径：/opt/venv，容器内固定路径）
    python3 -m venv /opt/venv && \
    # 3. 在虚拟环境中安装 requests + pyyaml（统一用虚拟环境的pip，减少缓存）
    /opt/venv/bin/pip install --no-cache-dir requests pyyaml && \
    # 4. 清理系统级缓存，减小镜像体积
    rm -rf /var/cache/apk/*

# 5. 设置环境变量，让系统优先使用虚拟环境的Python（可选，方便手动调用）
ENV PATH="/opt/venv/bin:$PATH"
###

#二、修改容器compose文件（qbittorrent范例）

###
services:
  qbittorrent:
    # 核心修改：指定 Dockerfile 所在目录和文件名
    build:
      context: /vol1/1000/Docker/python   # Dockerfile 所在的目录（你的 Python 目录）
      dockerfile: Dockerfile              # 文件名（就是你创建的 Dockerfile）
    image: lscr.io/linuxserver/qbittorrent:latest  # 镜像名保持不变，方便识别
    container_name: qbittorrent
    environment:
      - PUID=1000  
      - PGID=1000
      - TZ=Asia/Shanghai
      - WEBUI_PORT=8081
      - TORRENTING_PORT=26882
    volumes:
      - ****/config:/config    # qB 配置目录（不变）
      - ****/媒体库:/媒体库                        # 下载目录（不变）
      - ****/scripts:/scripts  # 映射分类脚本目录到容器内 /scripts（宿主机脚本放在 **** 目录下）
    ports:
      - 8081:8080
      - 26882:26882
      - 26882:26882/udp
    restart: unless-stopped
    #network_mode: "host"
###

#三、创建/scripts文件夹，包含config.yaml、qbit_classifier.py。

###自定义文件config.yaml
# qBittorrent 服务器配置
qbittorrent:
  host: "10.0.0.10"
  port: 8081
  username: "admin"
  password: "9763899"

# 存储路径配置
paths:
  base_dir: "/媒体库/下载"
  movies_dir: "电影"
  tv_dir: "剧集"
  other_dir: "其他"

# 分类标签（将显示在qBittorrent WebUI中）
categories:
  movie: "电影"
  tv: "剧集"
  other: "其他"

# 分类规则 - 仅英文模式正则表达式
# 剧集规则优先于电影规则
classification_rules:
  tv:
    # 关键修改：加 (?i) 表示不区分大小写，或把 S 改成 s
    - (?i)\bS\d{1,2}\b              # (?i) 确保匹配 S01、s01 都生效
    - (?i)\bS\d{1,2}[Ee]\d{1,2}\b   # 匹配 S01E01、s01e01 等
    - (?i)\bS\d{1,2}-[Ee]\d{1,2}\b  # 匹配 S01-E01、s01-e01 等
    - (?i)\bS\d{1,2}[_-]?\d{1,2}\b  # 匹配 S01_01、s01-01 等
    - (?i)\bSeason\s\d{1,2}\b       # 匹配 Season 1、season 1 等
    - (?i)\bComplete\sSeason\s\d{1,2}\b  # 匹配 Complete Season 1 等
  movie:
    - \b(19|20)\d{2}\b          # 保持不变，年份匹配
    - \((19|20)\d{2}\)\b        # 保持不变
    - \[(19|20)\d{2}\]\b        # 保持不变
    - (?i)\bMovie\b             # 加 (?i) 匹配 Movie、movie 等

###

###脚本qbit_classifier.py
#!/opt/venv/bin/python3
import re
import sys
import os
import logging
import argparse
import yaml
import requests

# 配置日志 - 确保qBittorrent能捕获
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - qbit_classifier - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/config/qbit_classifier.log'),  # 保存到qBittorrent配置目录
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

def load_config(config_path):
    """加载YAML配置文件"""
    try:
        with open(config_path, 'r', encoding='utf-8') as f:
            return yaml.safe_load(f)
    except FileNotFoundError:
        logger.error(f"配置文件 {config_path} 不存在")
        sys.exit(1)
    except yaml.YAMLError as e:
        logger.error(f"配置文件解析错误: {str(e)}")
        sys.exit(1)

def create_directories(config):
    """创建必要的目录并检查权限"""
    base_dir = config['paths']['base_dir']
    dirs = {
        # 关键修改：把 'movies' 改成 'movie'，和 classify_torrent 返回的 category 一致
        'movie': os.path.join(base_dir, config['paths']['movies_dir']),  
        'tv': os.path.join(base_dir, config['paths']['tv_dir']),
        'other': os.path.join(base_dir, config['paths']['other_dir'])
    }
    
    for dir_type, dir_path in dirs.items():
        try:
            os.makedirs(dir_path, exist_ok=True)
            # 设置目录权限为775，确保读写权限
            os.chmod(dir_path, 0o775)
            logger.debug(f"目录已准备: {dir_path} (权限: {oct(os.stat(dir_path).st_mode)[-3:]})")
        except OSError as e:
            logger.error(f"创建目录 {dir_path} 失败: {str(e)}")
            sys.exit(1)
    
    return dirs

def login_qbittorrent(config):
    """登录qBittorrent并获取认证Cookie"""
    host = config['qbittorrent']['host']
    port = config['qbittorrent']['port']
    username = config['qbittorrent']['username']
    password = config['qbittorrent']['password']
    
    url = f"http://{host}:{port}/api/v2/auth/login"
    headers = {
        "User-Agent": "qbit-classifier/1.0",
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    session = requests.Session()
    try:
        # 获取CSRF令牌
        session.get(url, headers=headers, timeout=10)
        csrf_token = session.cookies.get("XSRF-TOKEN", "")
        if csrf_token:
            headers["X-CSRF-Token"] = csrf_token
        
        # 执行登录
        response = session.post(
            url,
            data={"username": username, "password": password},
            headers=headers,
            timeout=10
        )
        
        if response.status_code == 200 and response.text == "Ok.":
            logger.info("登录qBittorrent成功")
            return session.cookies
        else:
            logger.error(f"登录失败: 状态码={response.status_code}, 响应={response.text}")
            sys.exit(1)
            
    except requests.exceptions.RequestException as e:
        logger.error(f"登录请求异常: {str(e)}")
        sys.exit(1)

def set_torrent_properties(cookies, config, torrent_hash, target_path, category):
    """设置种子的存储路径、分类标签和自动管理属性"""
    host = config['qbittorrent']['host']
    port = config['qbittorrent']['port']
    base_url = f"http://{host}:{port}/api/v2/torrents"
    
    headers = {
        "User-Agent": "qbit-classifier/1.0",
        "X-CSRF-Token": cookies.get("XSRF-TOKEN", ""),
        "Content-Type": "application/x-www-form-urlencoded"
    }
    
    # 1. 设置存储路径
    path_response = requests.post(
        f"{base_url}/setLocation",
        data={"hashes": torrent_hash, "location": target_path},
        cookies=cookies,
        headers=headers,
        timeout=10
    )
    
    if path_response.status_code != 200:
        logger.error(f"设置存储路径失败，状态码: {path_response.status_code}")
        return False
    
    # 2. 设置分类标签（用于自动管理）
    category_response = requests.post(
        f"{base_url}/setCategory",
        data={"hashes": torrent_hash, "category": category},
        cookies=cookies,
        headers=headers,
        timeout=10
    )
    
    if category_response.status_code != 200:
        logger.error(f"设置分类标签失败，状态码: {category_response.status_code}")
        return False
    
    # 3. 启用自动管理（确保种子遵循分类设置）
    auto_manage_response = requests.post(
        f"{base_url}/setAutoManagement",
        data={"hashes": torrent_hash, "enable": "true"},
        cookies=cookies,
        headers=headers,
        timeout=10
    )
    
    if auto_manage_response.status_code != 200:
        logger.error(f"启用自动管理失败，状态码: {auto_manage_response.status_code}")
        return False
    
    return True

def classify_torrent(name, config):
    """根据英文命名规则分类种子"""
    name_lower = name.lower()
    rules = config['classification_rules']
    
    # 优先检查剧集规则
    for pattern in rules['tv']:
        if re.search(pattern, name_lower):
            logger.debug(f"匹配剧集模式: {pattern} 在 {name} 中")
            return "tv"
    
    # 然后检查电影规则
    for pattern in rules['movie']:
        if re.search(pattern, name_lower):
            logger.debug(f"匹配电影模式: {pattern} 在 {name} 中")
            return "movie"
    
    # 其他类型
    return "other"

def main():
    logger.info("===== 种子分类处理开始 =====")
    
    # 解析必要的命令行参数
    parser = argparse.ArgumentParser(description='qBittorrent英文种子自动分类工具')
    parser.add_argument('hash', help='种子哈希值')
    parser.add_argument('name', help='种子名称')
    parser.add_argument('path', help='当前存储路径')
    parser.add_argument('-c', '--config', help='配置文件路径', default='/scripts/config.yaml')
    args = parser.parse_args()
    
    # 提取参数
    torrent_hash = args.hash
    torrent_name = args.name
    current_path = args.path
    config_path = args.config
    
    logger.info(f"处理种子: {torrent_name} (哈希: {torrent_hash[:8]}...)")
    logger.info(f"当前路径: {current_path}")
    
    # 加载配置
    config = load_config(config_path)
    
    # 创建目录
    dirs = create_directories(config)
    
    # 确定分类
    category = classify_torrent(torrent_name, config)
    category_label = config['categories'][category]
    target_path = dirs[category]
    
    logger.info(f"分类结果: {category_label}, 目标路径: {target_path}")
    
    # 检查是否已在目标位置
    if os.path.abspath(current_path) == os.path.abspath(target_path):
        logger.info("种子已在目标目录，无需调整")
        sys.exit(0)
    
    # 登录并设置种子属性
    cookies = login_qbittorrent(config)
    success = set_torrent_properties(cookies, config, torrent_hash, target_path, category_label)
    
    # 输出结果
    if success:
        logger.info(f"种子成功分类为 [{category_label}] 并启用自动管理")
        sys.exit(0)
    else:
        logger.error("种子分类或属性设置失败")
        sys.exit(1)

if __name__ == "__main__":
    main()
###






#四、SSH终端，cd到compose后sudo docker compose up -d --build

###类似下文
admin@FNNAS:/vol1/1000/Docker/qbittorrent$ sudo docker compose up -d --build
Compose can now delegate builds to bake for better performance.
 To do so, set COMPOSE_BAKE=true.
[+] Building 87.4s (7/7) FINISHED                                                                                                                                 docker:default
 => [qbittorrent internal] load build definition from Dockerfile                                                                                                            0.0s
 => => transferring dockerfile: 681B                                                                                                                                        0.0s
 => [qbittorrent internal] load metadata for docker.io/linuxserver/qbittorrent:latest                                                                                       0.0s
 => [qbittorrent internal] load .dockerignore                                                                                                                               0.0s
 => => transferring context: 2B                                                                                                                                             0.0s
 => CACHED [qbittorrent 1/2] FROM docker.io/linuxserver/qbittorrent:latest                                                                                                  0.0s
 => [qbittorrent 2/2] RUN apk update &&     apk add --no-cache python3 py3-pip &&     python3 -m venv /opt/venv &&     /opt/venv/bin/pip install --no-cache-dir requests   86.8s
 => [qbittorrent] exporting to image                                                                                                                                        0.4s 
 => => exporting layers                                                                                                                                                     0.4s 
 => => writing image sha256:a8c15c4b0932447b73e3f765e5a77522bb8fbfb83784793efaa88a7c622e046d                                                                                0.0s 
 => => naming to docker.io/linuxserver/qbittorrent:latest                                                                                                                   0.0s 
 => [qbittorrent] resolving provenance for metadata file                                                                                                                    0.0s 
[+] Running 2/2                                                                                                                                                                  
 ! qbittorrent Published ports are discarded when using host network mode                                                                                                   0.1s 
 ✔ Container qbittorrent   
###



#五、qbittorrent内勾选并填入新增 Torrent 时运行脚本

/opt/venv/bin/python3 /scripts/qbit_classifier.py "%I" "%N" "%F"

#六、测试

#1、进入容器内终端

sudo docker exec -it qbittorrent /bin/sh

#2、检查python是否安装

/opt/venv/bin/python3 --version
/opt/venv/bin/pip list | grep requests
/opt/venv/bin/python3 -c "import yaml; print('pyyaml版本：', yaml.__version__)"

#3、测试种子

root@FNNAS:/# /opt/venv/bin/python3 /scripts/qbit_classifier.py "f67743b40d8e2396b0261bee4a4724f98550fc43" "Love.is.for.the.Dogs.2025.S01.1080p.VIKI.WEB-DL.AAC2.0.H.264-DUSKLiGH
T" "/媒体库/下载"
2025-09-12 23:51:10,461 - qbit_classifier - INFO - ===== 种子分类处理开始 =====
2025-09-12 23:51:10,462 - qbit_classifier - INFO - 处理种子: Love.is.for.the.Dogs.2025.S01.1080p.VIKI.WEB-DL.AAC2.0.H.264-DUSKLiGHT (哈希: f67743b4...)
2025-09-12 23:51:10,462 - qbit_classifier - INFO - 当前路径: /媒体库/下载
2025-09-12 23:51:10,522 - qbit_classifier - INFO - 分类结果: 剧集, 目标路径: /媒体库/下载/剧集
2025-09-12 23:51:10,535 - qbit_classifier - INFO - 登录qBittorrent成功
2025-09-12 23:51:10,545 - qbit_classifier - INFO - 种子成功分类为 [剧集] 并启用自动管理



#七、上传真实种子，到web界面查看是否成功。
